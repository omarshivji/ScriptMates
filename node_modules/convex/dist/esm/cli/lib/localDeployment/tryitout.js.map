{
  "version": 3,
  "sources": ["../../../../../src/cli/lib/localDeployment/tryitout.ts"],
  "sourcesContent": ["// ----------------------------------------------------------------------------\n// Try it out (No account)\n\nimport path from \"path\";\nimport {\n  Context,\n  logMessage,\n  logVerbose,\n  logWarning,\n} from \"../../../bundler/context.js\";\nimport { promptSearch, promptString, promptYesNo } from \"../utils/prompts.js\";\nimport { bigBrainGenerateTryItOutAdminKey } from \"./bigBrain.js\";\nimport { LocalDeploymentError, printLocalDeploymentOnError } from \"./errors.js\";\nimport { loadDeploymentConfig } from \"./filePaths.js\";\nimport { rootDeploymentStateDir } from \"./filePaths.js\";\nimport { LocalDeploymentConfig } from \"./filePaths.js\";\nimport { DeploymentDetails } from \"./localDeployment.js\";\nimport { ensureBackendStopped, localDeploymentUrl } from \"./run.js\";\nimport { ensureBackendRunning } from \"./run.js\";\nimport { handlePotentialUpgrade } from \"./upgrade.js\";\nimport {\n  isOffline,\n  generateInstanceSecret,\n  choosePorts,\n  LOCAL_BACKEND_INSTANCE_SECRET,\n} from \"./utils.js\";\nimport { handleDashboard } from \"./dashboard.js\";\nimport crypto from \"crypto\";\nimport { ensureBackendBinaryDownloaded } from \"./download.js\";\n\nexport async function handleTryItOutDeployment(\n  ctx: Context,\n  options: {\n    ports?: {\n      cloud: number;\n      site: number;\n    };\n    backendVersion?: string;\n    dashboardVersion?: string;\n    forceUpgrade: boolean;\n    deploymentName: string | null;\n    chosenConfiguration: \"new\" | \"existing\" | \"ask\" | null;\n  },\n): Promise<DeploymentDetails> {\n  if (await isOffline()) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: \"Cannot run a try-it-out deployment in offline mode\",\n    });\n  }\n\n  const deployment = await chooseTryItOutDeployment(ctx, {\n    deploymentName: options.deploymentName,\n    chosenConfiguration: options.chosenConfiguration,\n  });\n  if (deployment.kind === \"first\") {\n    logMessage(\n      ctx,\n      \"This command, `npx convex dev`, will run your deployment and update it with the function you write in the `convex/` directory.\",\n    );\n    logMessage(\n      ctx,\n      \"Use `npx convex dashboard` to view and interact with your deployment from a web UI.\",\n    );\n    logMessage(\n      ctx,\n      \"Use `npx convex docs` to read the docs and `npx convex help` to see other commands.\",\n    );\n    if (process.stdin.isTTY) {\n      const result = await promptYesNo(ctx, {\n        message: \"Got it? Let's get started!\",\n        default: true,\n      });\n      if (!result) {\n        return ctx.crash({\n          exitCode: 1,\n          errorType: \"fatal\",\n          printedMessage: \"Exiting\",\n        });\n      }\n    }\n  }\n  ctx.registerCleanup(async (_exitCode, err) => {\n    if (err instanceof LocalDeploymentError) {\n      printLocalDeploymentOnError(ctx);\n    }\n  });\n  const { binaryPath, version } = await ensureBackendBinaryDownloaded(\n    ctx,\n    options.backendVersion === undefined\n      ? {\n          kind: \"latest\",\n        }\n      : { kind: \"version\", version: options.backendVersion },\n  );\n  await handleDashboard(ctx, version);\n  let adminKey: string;\n  let instanceSecret: string;\n  if (deployment.kind === \"existing\") {\n    adminKey = deployment.config.adminKey;\n    instanceSecret =\n      deployment.config.instanceSecret ?? LOCAL_BACKEND_INSTANCE_SECRET;\n    // If it's still running for some reason, exit and tell the user to kill it.\n    // It's fine if a different backend is running on these ports though since we'll\n    // pick new ones.\n    await ensureBackendStopped(ctx, {\n      ports: {\n        cloud: deployment.config.ports.cloud,\n      },\n      maxTimeSecs: 5,\n      deploymentName: deployment.deploymentName,\n      allowOtherDeployments: true,\n    });\n  } else {\n    instanceSecret = generateInstanceSecret();\n    const data = await bigBrainGenerateTryItOutAdminKey(ctx, {\n      instanceName: deployment.deploymentName,\n      instanceSecret,\n    });\n    adminKey = data.adminKey;\n  }\n\n  const [cloudPort, sitePort] = await choosePorts(ctx, {\n    count: 2,\n    startPort: 3210,\n    requestedPorts: [options.ports?.cloud ?? null, options.ports?.site ?? null],\n  });\n  const onActivity = async (isOffline: boolean, _wasOffline: boolean) => {\n    await ensureBackendRunning(ctx, {\n      cloudPort,\n      deploymentName: deployment.deploymentName,\n      maxTimeSecs: 5,\n    });\n    if (isOffline) {\n      return;\n    }\n  };\n\n  const { cleanupHandle } = await handlePotentialUpgrade(ctx, {\n    deploymentName: deployment.deploymentName,\n    deploymentKind: \"tryItOut\",\n    oldVersion:\n      deployment.kind === \"existing\" ? deployment.config.backendVersion : null,\n    newBinaryPath: binaryPath,\n    newVersion: version,\n    ports: { cloud: cloudPort, site: sitePort },\n    adminKey,\n    instanceSecret,\n    forceUpgrade: options.forceUpgrade,\n  });\n\n  const cleanupFunc = ctx.removeCleanup(cleanupHandle);\n  ctx.registerCleanup(async (exitCode, err) => {\n    if (cleanupFunc !== null) {\n      await cleanupFunc(exitCode, err);\n    }\n  });\n\n  return {\n    adminKey,\n    deploymentName: deployment.deploymentName,\n    deploymentUrl: localDeploymentUrl(cloudPort),\n    onActivity,\n  };\n}\n\nexport async function loadTryItOutDeployment(\n  ctx: Context,\n  deploymentName: string,\n): Promise<LocalDeploymentConfig> {\n  const config = loadDeploymentConfig(ctx, \"tryItOut\", deploymentName);\n  if (config === null) {\n    return ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `Could not find deployment with name ${deploymentName}!`,\n    });\n  }\n  return config;\n}\n\nexport async function listExistingTryItOutDeployments(ctx: Context): Promise<\n  Array<{\n    deploymentName: string;\n    config: LocalDeploymentConfig;\n  }>\n> {\n  const dir = rootDeploymentStateDir(\"tryItOut\");\n  if (!ctx.fs.exists(dir)) {\n    return [];\n  }\n  const deploymentNames = ctx.fs.listDir(dir).map((d) => d.name);\n  return deploymentNames.flatMap((deploymentName) => {\n    const config = loadDeploymentConfig(ctx, \"tryItOut\", deploymentName);\n    if (config !== null) {\n      return [{ deploymentName, config }];\n    }\n    return [];\n  });\n}\n\nasync function chooseTryItOutDeployment(\n  ctx: Context,\n  options: {\n    deploymentName: string | null;\n    chosenConfiguration: \"new\" | \"existing\" | \"ask\" | null;\n  },\n): Promise<\n  | {\n      kind: \"existing\";\n      deploymentName: string;\n      config: LocalDeploymentConfig;\n    }\n  | {\n      kind: \"new\";\n      deploymentName: string;\n    }\n  | {\n      kind: \"first\";\n      deploymentName: string;\n    }\n> {\n  const deployments = await listExistingTryItOutDeployments(ctx);\n  if (options.deploymentName !== null && options.chosenConfiguration === null) {\n    const existing = deployments.find(\n      (d) => d.deploymentName === options.deploymentName,\n    );\n    if (existing === undefined) {\n      logWarning(\n        ctx,\n        `Could not find deployment with name ${options.deploymentName}!`,\n      );\n    } else {\n      return {\n        kind: \"existing\",\n        deploymentName: existing.deploymentName,\n        config: existing.config,\n      };\n    }\n  }\n  if (deployments.length === 0) {\n    logMessage(\n      ctx,\n      \"Welcome to developing with Convex. Let's set up your first deployment.\",\n    );\n    return await promptForNewDeployment(ctx, []);\n  }\n\n  if (options.chosenConfiguration === \"new\") {\n    const deploymentName = await promptString(ctx, {\n      message: \"Choose a name for your new deployment:\",\n      default: path.basename(process.cwd()),\n    });\n    return {\n      kind: \"new\",\n      deploymentName: await getUniqueName(\n        ctx,\n        deploymentName,\n        deployments.map((d) => d.deploymentName),\n      ),\n    };\n  }\n\n  const newOrExisting = await promptSearch(ctx, {\n    message: \"Which deployment would you like to use?\",\n    choices: [\n      ...(options.chosenConfiguration === \"existing\"\n        ? []\n        : [\n            {\n              name: \"Create a new one\",\n              value: \"new\",\n            },\n          ]),\n      ...deployments.map((d) => ({\n        name: d.deploymentName,\n        value: d.deploymentName,\n      })),\n    ],\n  });\n\n  if (newOrExisting !== \"new\") {\n    const existingDeployment = deployments.find(\n      (d) => d.deploymentName === newOrExisting,\n    );\n    if (existingDeployment === undefined) {\n      return ctx.crash({\n        exitCode: 1,\n        errorType: \"fatal\",\n        printedMessage: `Could not find deployment with name ${newOrExisting}!`,\n      });\n    }\n    return {\n      kind: \"existing\",\n      deploymentName: existingDeployment.deploymentName,\n      config: existingDeployment.config,\n    };\n  }\n  return await promptForNewDeployment(\n    ctx,\n    deployments.map((d) => d.deploymentName),\n  );\n}\n\nasync function promptForNewDeployment(\n  ctx: Context,\n  existingNames: string[],\n): Promise<\n  | {\n      kind: \"first\";\n      deploymentName: string;\n    }\n  | {\n      kind: \"new\";\n      deploymentName: string;\n    }\n> {\n  const isFirstDeployment = existingNames.length === 0;\n  const message = isFirstDeployment\n    ? \"Choose a name for your first deployment:\"\n    : \"Choose a name:\";\n  const deploymentName = await promptString(ctx, {\n    message,\n    default: path.basename(process.cwd()),\n  });\n\n  const uniqueName = await getUniqueName(ctx, deploymentName, existingNames);\n  logVerbose(ctx, `Deployment name: ${uniqueName}`);\n  return isFirstDeployment\n    ? {\n        kind: \"first\",\n        deploymentName: `tryitout-${uniqueName}`,\n      }\n    : {\n        kind: \"new\",\n        deploymentName: `tryitout-${uniqueName}`,\n      };\n}\n\nasync function getUniqueName(\n  ctx: Context,\n  name: string,\n  existingNames: string[],\n) {\n  if (!existingNames.includes(name)) {\n    return name;\n  }\n  for (let i = 1; i <= 5; i++) {\n    const uniqueName = `${name}-${i}`;\n    if (!existingNames.includes(uniqueName)) {\n      return uniqueName;\n    }\n  }\n  const randomSuffix = crypto.randomBytes(4).toString(\"hex\");\n\n  const uniqueName = `${name}-${randomSuffix}`;\n  if (!existingNames.includes(uniqueName)) {\n    return uniqueName;\n  }\n  return ctx.crash({\n    exitCode: 1,\n    errorType: \"fatal\",\n    printedMessage: `Could not generate a unique name for your deployment, please choose a different name`,\n  });\n}\n"],
  "mappings": "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",
  "names": ["isOffline", "uniqueName"]
}
